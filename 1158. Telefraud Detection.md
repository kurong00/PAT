# Telefraud Detection (25 分)

Telefraud（电信诈骗） remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.

A person must be detected as a suspect if he/she makes more than KKK short phone calls to **different** people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. AAA makes a **short** phone call to BBB means that the total duration of the calls from AAA to BBB is no more than 5 minutes.

### Input Specification:

Each input file contains one test case. For each case, the first line gives 3 positive integers KKK (≤500\\le 500≤500, the threshold（阈值） of the amount of short phone calls), NNN (≤103\\le 10^3≤10​3​​, the number of different phone numbers), and MMM (≤105\\le 10^5≤10​5​​, the number of phone call records). Then MMM lines of one day's records are given, each in the format:

    caller receiver duration
    

where `caller` and `receiver` are numbered from 1 to NNN, and `duration` is no more than 1440 minutes in a day.

### Output Specification:

Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.

If no one is detected, output `None` instead.

### Sample Input 1:

    5 15 31
    1 4 2
    1 5 2
    1 5 4
    1 7 5
    1 8 3
    1 9 1
    1 6 5
    1 15 2
    1 15 5
    3 2 2
    3 5 15
    3 13 1
    3 12 1
    3 14 1
    3 10 2
    3 11 5
    5 2 1
    5 3 10
    5 1 1
    5 7 2
    5 6 1
    5 13 4
    5 15 1
    11 10 5
    12 14 1
    6 1 1
    6 9 2
    6 10 5
    6 11 2
    6 12 1
    6 13 1
    

### Sample Output 1:

    3 5
    6
    

**Note:** In sample 1, although `1` had 9 records, but there were 7 distinct receivers, among which `5` and `15` both had conversations lasted more than 5 minutes in total. Hence `1` had made 5 short phone calls and didn't exceed the threshold 5, and therefore is not a suspect.

### Sample Input 2:

    5 7 8
    1 2 1
    1 3 1
    1 4 1
    1 5 1
    1 6 1
    1 7 1
    2 1 1
    3 1 1
    

### Sample Output 2:

    None

### 题目解析

首先找出嫌疑人名单，要求是：

- 短通话的记录（小于5分钟）> k（阈值）
- 打入电话的个数 < 打出电话个数 * 20%

然后查找嫌疑人帮派，这里可以用 DFS 或者 并查集

```C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int N = 1001;
int call[N][N], in[N], out[N], visit[N];
vector<int> suspects, tempGang;
vector<vector<int>> ans;
void DFS(int x) {
	if (!visit[x]) {
		tempGang.push_back(x);
		visit[x] = 1;
		for (int i = 0; i < suspects.size(); i++)
			if (!visit[suspects[i]] && call[x][suspects[i]] && call[suspects[i]][x])
				DFS(suspects[i]);
	}
}
int main() {
	int k, n, m; cin >> k >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b, c; cin >> a >> b >> c;
		call[a][b] += c;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (call[i][j] != 0 && call[i][j] <= 5) {
				out[i]++;
				if (call[j][i] != 0) in[i]++;
			}
	for (int i = 1; i <= n; i++)
		if (out[i] > k && out[i] >= in[i] * 5) suspects.push_back(i);
	for (int i = 0; i < suspects.size(); i++) {
		if (!visit[suspects[i]]) {
			tempGang.clear();
			DFS(suspects[i]);
			if (tempGang.size()) ans.push_back(tempGang);
		}
	}
	if (ans.size() == 0) cout << "None";
	else
		for (int i = 0; i < ans.size(); i++) {
			for (int j = 0; j < ans[i].size(); j++)
				cout << (j != 0 ? " " : "") << ans[i][j];
			cout << endl;
		}
	return 0;
}

```